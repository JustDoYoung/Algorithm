## 2178.  미로찾기
#### 문제 핵심
- (N, M) 좌표까지 최소 칸 수를 구하라.
- N x M 맵은 0 또는 1로 이루어 짐 -> 가중치가 같은 맵
- 따라서 BFS로 접근한다.

#### 풀이
```c++
int N, M;
int arr[104][104];
int visited[104][104];

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

void bfs()
{
    int x, y;
    x = 0, y = 0;
    visited[y][x] = 1;
    queue<pair<int, int>> q;
    q.push({y, x});

    while (q.size())
    {
        tie(y, x) = q.front();
        q.pop();

        for (int i = 0; i < 4; i++)
        {
            int dy = y + dirY[i];
            int dx = x + dirX[i];

            if (dy < 0 || dy >= N || dx < 0 || dx >= M)
                continue;
            if (visited[dy][dx])
                continue;
            if (arr[dy][dx] == 0)
                continue;

            q.push({dy, dx});
            visited[dy][dx] = visited[y][x] + 1;
        }
    }
}
```

## 1012.  유기농 배추
#### 문제 핵심
- N x M 크기의 맵에 연결된 컴포넌트의 개수를 찾는 문제.
- DFS를 사용해 접근한다.

```c++
#include "bits/stdc++.h"

using namespace std;

int T, N, M, K;
int cnt = 0;

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

void dfs(int arr[][54], bool visited[][54], int y, int x)
{
    if (visited[y][x])
        return;

    visited[y][x] = 1;

    for (int i = 0; i < 4; i++)
    {
        int dy = y + dirY[i];
        int dx = x + dirX[i];

        if (dy < 0 || dy >= N || dx < 0 || dx >= M)
            continue;
        if (visited[dy][dx])
            continue;
        if (arr[dy][dx] == 0)
            continue;

        dfs(arr, visited, dy, dx);
    }
}
int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> T;

    while (T--)
    {
        cin >> M >> N >> K;

        int arr[54][54] = {0};
        bool visited[54][54] = {0};

        for (int i = 0; i < K; i++)
        {
            int y, x;
            cin >> x >> y;

            arr[y][x] = 1;
        }

        for (int j = 0; j < N; j++)
        {
            for (int i = 0; i < M; i++)
            {
                if (visited[j][i])
                    continue;
                if (arr[j][i] == 0)
                    continue;

                dfs(arr, visited, j, i);
                cnt++;
            }
        }

        cout << cnt << '\n';
        cnt = 0;
    }
}
```
- 이 문제에서 헤맨 부분은 문제에서 입력으로 들어오는 부분을 대충 읽고 처리해서 x, y를 뒤바꿔 처리한 부분이었다.
- 평소에는 행렬의 y 방향부터 처리하느라 입력도 y를 우선적으로 처리를 했는데 문제에선 x부터 받았었으니 값이 뒤집혀서 행렬이 만들어 졌다.
- 그리고 행렬을 초기화하는 부분을 생략해서 무작위 값이 행렬에 부여되는 부분도 있었다.

## 2468.  안전 영역
#### 문제 핵심
- 수심이 1m씩 높아짐에 따라 생기는 안전 지역(섬)의 개수 중 최대 개수수를 구한다.
- 맵 행렬의 요소 값들을 1씩 감소시키면서 dfs를 통해 연결된 컴포넌트의 개수를 구한다.
- 연결된 컴포넌트가 0이 될 때까지 반복하고 최대 개수를 출력한다.

```c++
#include "bits/stdc++.h"

using namespace std;

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

int N;
int arr[104][104];
int ans;

void dfs(int, int, bool[][104]);

int solve()
{
    bool visited[104][104] = {0};
    int cnt = 0;

    for (int y = 0; y < N; y++)
    {
        for (int x = 0; x < N; x++)
            arr[y][x] = max(--arr[y][x], 0);
    }

    for (int y = 0; y < N; y++)
    {
        for (int x = 0; x < N; x++)
        {
            if (visited[y][x])
                continue;
            if (arr[y][x] == 0)
                continue;

            dfs(y, x, visited);
            cnt++;
        }
    }

    return cnt;
}

void dfs(int y, int x, bool visited[][104])
{
    if (visited[y][x])
        return;

    visited[y][x] = 1;

    for (int i = 0; i < 4; i++)
    {
        int dy = y + dirY[i];
        int dx = x + dirX[i];

        if (dy < 0 || dy >= N || dx < 0 || dx >= N)
            continue;
        if (arr[dy][dx] == 0)
            continue;
        if (visited[dy][dx])
            continue;

        dfs(dy, dx, visited);
    }
}
int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    for (int y = 0; y < N; y++)
    {
        for (int x = 0; x < N; x++)
            cin >> arr[y][x];
    }

    while (int tmp = solve())
    {
        ans = max(ans, tmp);
    }

    ans = ans == 0 ? 1 : ans;
    cout << ans << '\n';
}
```
- 모든 지역의 높이가 1로 동일해서 연결된 컴포넌트가 1개밖에 나오지 않을 때 처리를 하지 않아 오답이 나왔다.
- 모든 지역의 높이가 1일 경우에는 ans가 0이 되기 때문에 마지막에 예외처리를 해야한다.

## 2583.  영역 구하기
#### 문제 핵심
- M x N 크기의 맵에서 직사각형 영역이 아닌 영역의 개수와 각각의 넓이를 구한다.
- 직사각형 영역은 1씩 더하고 dfs로 탐색하면서 연결된 컴포넌트의 개수와 넓이를 구한다.
- 입력으로 들어오는 값은 x, y 좌표이므로 맵 행렬에서 직사각형 영역의 범위에 신경쓰도록 한다.

```c++
#include "bits/stdc++.h"

using namespace std;

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

int M, N, K;
int arr[104][104];
int visited[104][104];

int cnt = 0;
int ar = 0;
vector<int> area;

void dfs(int, int);

void solve()
{
    for (int y = 0; y < M; y++)
    {
        for (int x = 0; x < N; x++)
        {
            if (visited[y][x])
                continue;
            if (arr[y][x] != 0)
                continue;

            dfs(y, x);
            cnt++;
            area.push_back(ar);
            ar = 0;
        }
    }

    sort(area.begin(), area.end());
}

void dfs(int y, int x)
{
    visited[y][x] = 1;
    ar++;

    for (int i = 0; i < 4; i++)
    {
        int dy = y + dirY[i];
        int dx = x + dirX[i];

        if (dy < 0 || dy >= M || dx < 0 || dx >= N)
            continue;
        if (arr[dy][dx] != 0)
            continue;
        if (visited[dy][dx])
            continue;

        dfs(dy, dx);
    }
}
int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> M >> N >> K;

    for (int i = 0; i < K; i++)
    {
        int x1, y1, x2, y2;

        cin >> x1 >> y1 >> x2 >> y2;

        for (int j = y1; j < y2; j++)
        {
            for (int i = x1; i < x2; i++)
                arr[j][i]++;
        }
    }

    solve();

    cout << cnt << '\n';
    for (int i : area)
        cout << i << ' ';
}
```

## 1992. 쿼드트리
#### 문제 핵심
- N x N 맵에서 0 또는 1로만 이루어진 인접한 집합들을 묶어서 출력해야 한다.
- 맵 전체를 먼저 탐색하고 0과 1이 섞여 있으면 탐색 범위를 1/2씩 줄이면서 0이나 1로만 이루어진 집합이 있을 때까지 탐색한다.
- 4구역을 탐색하는 순서에 따라 재귀함수를 호출하는 것이 관건

```c++
#include "bits/stdc++.h"

using namespace std;

int N;
char arr[70][70] = {'0'};

string solve(int y, int x, int width)
{
    if (width == 1)
        return string(1, arr[y][x]);

    char now = arr[y][x];
    string ans = "";

    for (int j = y; j < y + width; j++)
    {
        for (int i = x; i < x + width; i++)
        {
            if (now != arr[j][i])
            {
                ans += '(';
                ans += solve(y, x, width / 2);
                ans += solve(y, x + width / 2, width / 2);
                ans += solve(y + width / 2, x, width / 2);
                ans += solve(y + width / 2, x + width / 2, width / 2);
                ans += ')';

                return ans;
            }
        }
    }

    return string(1, arr[y][x]);
}

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    for (int j = 0; j < N; j++)
    {
        string input;
        cin >> input;

        for (int i = 0; i < N; i++)
            arr[j][i] = input[i];
    }

    cout << solve(0, 0, N) << '\n';

    return 0;
}
```

## 2828. 사과 담기 게임
#### 문제 핵심
- 바구니의 시작 위치와 끝 위치를 기억한다.
- 사과가 떨어지는 위치가 바구니 범위 안에 드는지 체크한다.
- 바구니의 시작위치보다 작은 위치일 때 끝위치보다 큰 위치일 때를 구분해서 바구니를 이동한다.
- 이동 후 바구니의 시작위치와 끝 위치를 갱신한다.
```c++
#include "bits/stdc++.h"

using namespace std;

int N, M, J;

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N >> M >> J;

    int s = 1;
    int e = s + M - 1;
    int ans = 0;

    for (int i = 0; i < J; i++)
    {
        int spot;
        cin >> spot;

        if (spot < s)
        {
            ans += s - spot;
            s = spot;
            e = s + M - 1;
        }
        else if (e < spot)
        {
            ans += spot - e;
            e = spot;
            s = e - M + 1;
        }
    }

    cout << ans << endl;

    return 0;
}
```

## 2910. 빈도 정렬
#### 문제 핵심
- 숫자가 들어오는 순서를 지키면서 숫자의 빈도순대로 정렬하는 것이 핵심.
```c++
#include <bits/stdc++.h>

using namespace std;

int N, C;

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    map<int, int> m;
    vector<pair<int, int>> v;

    cin >> N >> C;

    while (N--)
    {
        int input;
        cin >> input;

        if (m.find(input) == m.end())
        {
            m[input] = 0;
            v.push_back({input, 0});
        }

        m[input]++;
    }

    for (auto &ele : v)
        ele.second = m[ele.first];

    stable_sort(v.begin(), v.end(), [](auto a, auto b)
         { return a.second > b.second; });

    for (auto ele : v)
        for (int i = 0; i < ele.second; i++)
            cout << ele.first << ' ';

    return 0;
}
```
- sort 함수는 정렬할 때 리스트의 순서를 지키지 않을 수 있다.
- statble_sort 함수는 리스트의 상대위치를 지키면서 정렬을 한다.
- sort를 사용한다면 숫자가 나온 순서를 저장하는 자료구조를 추가해야한다.

## 4659. 비밀번호 발음하기
#### 문제핵심
- 주어진 규칙을 코드로 구현하면 되는 문제
- 다만 규칙을 빠르게 해석하고 로직을 짜고 코드로 구현하는 흐름을 숙달할 필요가 있음
```c++
#include <bits/stdc++.h>

using namespace std;

set<char> s{'a', 'e', 'i', 'o', 'u'};

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    while (true)
    {
        string input;
        cin >> input;

        if (input == "end")
            break;

        pair<int, int> cnt = {0, 0}; //{자음, 모음}
        char prev = '\0';
        bool acceptable = true;
        bool check = false;

        for (char c : input)
        {
            if (prev == c)
            {
                if (cnt.second == 1 && (c == 'e' || c == 'o'))
                {
                    cnt.first = 0;
                    cnt.second++;
                    continue;
                }

                acceptable = false;
                break;
            }

            if (s.find(c) != s.end())
            {
                check = true;
                cnt.first = 0;
                cnt.second++;

                if (cnt.second >= 3)
                {
                    acceptable = false;
                    break;
                }
            }
            else
            {
                cnt.second = 0;
                cnt.first++;

                if (cnt.first >= 3 || prev == c)
                {
                    acceptable = false;
                    break;
                }
            }

            prev = c;
        }

        if (check == false)
            acceptable = false;

        if (acceptable)
            cout << '<' << input << '>' << " is acceptable.\n";
        else
            cout << '<' << input << '>' << " is not acceptable.\n";
    }

    return 0;
}

```

## 2870. 수학숙제
#### 문제핵심
- 숫자와 문자가 섞여있는 문자열에서 숫자만 솎아낸다.
- 문자열을 순회하면서 알파벳이 나올 때마다 substr을 한다.
```c++
#include <bits/stdc++.h>

using namespace std;

int N;
vector<string> v;

string RemoveZero(string input)
{
    int s = 0;
    for (s = 0; s < input.length() - 1; s++)
    {
        if (input[s] != '0')
            break;
    }

    return input.substr(s);
}

void GetNumbers(string input)
{
    int s = 0;

    for (int i = 0; i < input.length(); i++)
    {
        if (isalpha(input[i]))
        {
            string tmp = input.substr(s, i - s);
            s = i + 1;

            if (tmp == "")
                continue;

            v.push_back(RemoveZero(tmp));
        }
    }

    if (s != input.length())
    {
        string tmp = input.substr(s);
        v.push_back(RemoveZero(tmp));
    }
}

bool Compare(string a, string b)
{
    if (a.length() == b.length())
        return a < b;

    return a.length() < b.length();
}

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    while (N--)
    {
        string input;
        cin >> input;

        GetNumbers(input);
    }

    sort(v.begin(), v.end(), Compare);

    for (string i : v)
        cout << i << '\n';

    return 0;
}

```
- 문자열이 최대 100자가 될 수 있는데 모두 숫자로 이뤄진 경우 매우 큰 숫자가 된다.
- 따라서 **atoi(s.c_str())** 로 숫자를 컨테이너에 저장하면 안 된다.

## 10709. 기상캐스터
#### 문제핵심
- 행별로 'c' 문자가 나온 인덱스를 알아낸다.
- '.'가 나온 위치에는 몇 분 뒤에 'c'가 올 지 예측한다.
- 단, 새로운 'c'가 나오면 이후 인덱스의 시간도 처음부터 계산한다.
- 'c'가 1분마다 1칸씩 오른쪽으로 이동한다.
```c++
#include <bits/stdc++.h>

using namespace std;

int H, W;
vector<string> v;

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> H >> W;

    for (int i = 0; i < H; i++)
    {
        string input;
        cin >> input;
        v.push_back(input);
    }

    for (string row : v)
    {
        int pivot = -1;
        for (int j = 0; j < row.size(); j++)
        {
            int output = -1;

            if (row[j] == 'c')
                pivot = j;

            if (pivot != -1)
                output = j - pivot;

            cout << output << ' ';
        }
        cout << '\n';
    }

    return 0;
}
```

## 3474. 교수가 된 현우
#### 문제핵심
- N!를 계산했을 때 오른쪽부터 0으로만 차지한 자리수는 몇 개인가
- N은 최대 10억으로 주어지기 때문에 직접 계산하면 안 된다.
``` c++
#include <bits/stdc++.h>

using namespace std;

int T;

size_t solve(int num)
{
    int cnt2 = 0;
    int cnt5 = 0;

    for (int i = 2; i <= num; i *= 2)
    {
        cnt2 += num / i;
    }

    for (int i = 5; i <= num; i *= 5)
    {
        cnt5 += num / i;
    }

    return min(cnt2, cnt5);
}

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> T;

    while (T--)
    {
        int input;
        cin >> input;

        cout << solve(input) << '\n';
    }

    return 0;
}
```
- 10으로 나눠떨어지는 순간마다 카운트하고 값은 1/10하는 로직을 시도해봤지만 정수범위를 넘어서기 때문에 오답이 나온다.
- N!를 계산할 때 0으로 자릿수를 채우는 경우는 **2의 배수 x 5의 배수** 연산이 나올 경우다.
- 따라서, 1~N 범위에 2의 배수와 5의 배수가 포함된 개수를 구한 다음 10이 만들어지는 개수가 곧 정답이다.

## 2852. NBA 농구
#### 문제핵심
- 골이 들어갈 때마다 팀 스코어를 비교해서 시간 차를 이기고 있는 팀에 더해준다.
```c++
#include <bits/stdc++.h>

using namespace std;

int N, prevTime = 0;
pair<int, int> score = {0, 0}; // 1팀 : 2팀
pair<int, int> winningTime = {0, 0};

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    while (N--)
    {
        int team;
        string time_s;

        cin >> team >> time_s;

        size_t minute = atoi(time_s.substr(0, 2).c_str());
        size_t second = atoi(time_s.substr(3).c_str());
        size_t time = minute * 60 + second;

        if (score.first > score.second)
        {
            winningTime.first += time - prevTime;
        }
        else if (score.first < score.second)
        {
            winningTime.second += time - prevTime;
        }

        if (team == 1)
            score.first++;
        else
            score.second++;

        prevTime = time;
    }

    size_t remainTime = 48 * 60 - prevTime;
    if (score.first > score.second)
    {
        winningTime.first += remainTime;
    }
    else if (score.first < score.second)
    {
        winningTime.second += remainTime;
    }

    int ans1 = winningTime.first;
    int ans2 = winningTime.second;

    cout << put_time(new tm{tm_sec : ans1 % 60, tm_min : ans1 / 60}, "%M:%S") << '\n';
    cout << put_time(new tm{ans2 % 60, ans2 / 60}, "%M:%S") << '\n';

    return 0;
}
```

## 1436. 영화감독 숌
#### 문제핵심
- "666"이 포함된 숫자 중 N번째 숫자를 구한다.
- 브루트포스 알고리즘
```c++
#include <bits/stdc++.h>

using namespace std;

int N;

int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> N;

    int num = 666;

    while (true)
    {
        string num_s = to_string(num);
        if (num_s.find("666") != string::npos)
            N--;
        if (N == 0)
            break;
        num++;
    }

    cout << num << '\n';

    return 0;
}
```
- 숫자가 최대 10000이기 때문에 완전탐색을 해도 무방하다.