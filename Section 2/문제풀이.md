## 2178.  미로찾기
#### 문제 핵심
- (N, M) 좌표까지 최소 칸 수를 구하라.
- N x M 맵은 0 또는 1로 이루어 짐 -> 가중치가 같은 맵
- 따라서 BFS로 접근한다.

#### 풀이
```c++
int N, M;
int arr[104][104];
int visited[104][104];

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

void bfs()
{
    int x, y;
    x = 0, y = 0;
    visited[y][x] = 1;
    queue<pair<int, int>> q;
    q.push({y, x});

    while (q.size())
    {
        tie(y, x) = q.front();
        q.pop();

        for (int i = 0; i < 4; i++)
        {
            int dy = y + dirY[i];
            int dx = x + dirX[i];

            if (dy < 0 || dy >= N || dx < 0 || dx >= M)
                continue;
            if (visited[dy][dx])
                continue;
            if (arr[dy][dx] == 0)
                continue;

            q.push({dy, dx});
            visited[dy][dx] = visited[y][x] + 1;
        }
    }
}
```

## 1012.  유기농 배추
#### 문제 핵심
- N x M 크기의 맵에 연결된 컴포넌트의 개수를 찾는 문제.
- DFS를 사용해 접근한다.

```c++
#include "bits/stdc++.h"

using namespace std;

int T, N, M, K;
int cnt = 0;

int dirY[] = {1, 0, -1, 0};
int dirX[] = {0, 1, 0, -1};

void dfs(int arr[][54], bool visited[][54], int y, int x)
{
    if (visited[y][x])
        return;

    visited[y][x] = 1;

    for (int i = 0; i < 4; i++)
    {
        int dy = y + dirY[i];
        int dx = x + dirX[i];

        if (dy < 0 || dy >= N || dx < 0 || dx >= M)
            continue;
        if (visited[dy][dx])
            continue;
        if (arr[dy][dx] == 0)
            continue;

        dfs(arr, visited, dy, dx);
    }
}
int main()
{
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    cin >> T;

    while (T--)
    {
        cin >> M >> N >> K;

        int arr[54][54] = {0};
        bool visited[54][54] = {0};

        for (int i = 0; i < K; i++)
        {
            int y, x;
            cin >> x >> y;

            arr[y][x] = 1;
        }

        for (int j = 0; j < N; j++)
        {
            for (int i = 0; i < M; i++)
            {
                if (visited[j][i])
                    continue;
                if (arr[j][i] == 0)
                    continue;

                dfs(arr, visited, j, i);
                cnt++;
            }
        }

        cout << cnt << '\n';
        cnt = 0;
    }
}
```
#### 코멘트
- 이 문제에서 헤맨 부분은 문제에서 입력으로 들어오는 부분을 대충 읽고 처리해서 x, y를 뒤바꿔 처리한 부분이었다.
- 평소에는 행렬의 y 방향부터 처리하느라 입력도 y를 우선적으로 처리를 했는데 문제에선 x부터 받았었으니 값이 뒤집혀서 행렬이 만들어 졌다.
- 그리고 행렬을 초기화하는 부분을 생략해서 무작위 값이 행렬에 부여되는 부분도 있었다.